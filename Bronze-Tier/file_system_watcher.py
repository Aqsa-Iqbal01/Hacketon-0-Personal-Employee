"""
File System Watcher - Monitors a specific folder for new file drops

Triggers when files are dropped into a designated folder and creates action files
for the AI to process.
"""

import time
import logging
import shutil
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from base_watcher import BaseWatcher

class DropFolderHandler(FileSystemEventHandler):
    def __init__(self, vault_path: str, watch_path: str):
        """
        Initialize the file drop handler.

        Args:
            vault_path (str): Path to the Obsidian vault
            watch_path (str): Path to the folder to monitor
        """
        self.vault_path = Path(vault_path)
        self.needs_action = self.vault_path / 'Needs_Action'
        self.watch_path = Path(watch_path)
        
        # Ensure Needs_Action folder exists
        self.needs_action.mkdir(parents=True, exist_ok=True)
        
        self.logger = logging.getLogger('DropFolderHandler')
        self.logger.info(f'Monitoring {self.watch_path} for file drops')
        self.logger.info(f'Needs_Action folder: {self.needs_action}')

    def on_created(self, event):
        """
        Called when a file is created in the watched folder.
        """
        if event.is_directory:
            return

        source = Path(event.src_path).resolve()
        dest = self.needs_action / f'FILE_{source.name}'
        
        # Skip if file is already in Needs_Action folder
        if source.parent == self.needs_action:
            return

        try:
            # Copy the file to the Needs_Action folder
            shutil.copy2(source, dest)
            self.logger.info(f'Copied file: {source.name} -> {dest}')

            # Create metadata file with the same base name
            self.create_metadata(source, dest)

            self.logger.info(f'Processed file drop: {source.name}')

        except Exception as e:
            self.logger.error(f'Error processing file {source.name}: {e}')

    def create_metadata(self, source: Path, dest: Path):
        """
        Create a metadata file with information about the dropped file.

        Args:
            source (Path): Original file path
            dest (Path): Destination file path in Needs_Action
        """
        meta_path = dest.with_suffix('.md')
        
        # Ensure Needs_Action folder exists
        self.needs_action.mkdir(parents=True, exist_ok=True)

        content = f"""---
name: {source.name}
type: file_drop
size: {source.stat().st_size} bytes
original_path: {source}
received: {time.strftime('%Y-%m-%d %H:%M:%S')}
status: pending
---

# File Drop Notification

A new file has been dropped for processing:

- **File Name**: {source.name}
- **Size**: {source.stat().st_size} bytes
- **Original Location**: {source}

## Suggested Actions

- [ ] Review file contents
- [ ] Process according to file type
- [ ] Take appropriate action based on content
- [ ] Move to appropriate folder after processing

---
*This file was automatically generated by the File System Watcher.*"""

        try:
            meta_path.write_text(content, encoding='utf-8')
            self.logger.info(f'Created metadata file: {meta_path}')
        except Exception as e:
            self.logger.error(f'Error creating metadata file {meta_path}: {e}')

class FileSystemWatcher(BaseWatcher):
    def __init__(self, vault_path: str, watch_path: str, check_interval: int = 60):
        """
        Initialize the file system watcher.

        Args:
            vault_path (str): Path to the Obsidian vault
            watch_path (str): Path to the folder to monitor
            check_interval (int): Time between checks in seconds
        """
        super().__init__(vault_path, check_interval)
        self.watch_path = Path(watch_path)

        # Set up the watchdog observer
        self.observer = Observer()
        self.event_handler = DropFolderHandler(vault_path, watch_path)

        # Create the watch path if it doesn't exist
        self.watch_path.mkdir(parents=True, exist_ok=True)

        self.logger.info(f'FileSystemWatcher initialized for {self.watch_path}')

    def check_for_updates(self) -> list:
        """
        Check for new files in the watch folder.

        Returns:
            list: List of new file paths
        """
        # This method is primarily for the base class interface
        # The actual file monitoring happens through watchdog
        return []

    def create_action_file(self, item) -> Path:
        """
        Not used directly by FileSystemWatcher (uses DropFolderHandler instead).
        """
        raise NotImplementedError('FileSystemWatcher uses DropFolderHandler')

    def run(self):
        """
        Start the file system watcher.
        """
        # Set up the observer
        self.observer.schedule(
            self.event_handler,
            self.watch_path,
            recursive=False
        )
        self.observer.start()

        self.logger.info(f'Started FileSystemWatcher for {self.watch_path}')

        try:
            while True:
                time.sleep(self.check_interval)
        except KeyboardInterrupt:
            self.observer.stop()
        self.observer.join()

if __name__ == "__main__":
    import sys

    # Set up logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('file_watcher.log'),
            logging.StreamHandler(sys.stdout)
        ]
    )

    # Use the Personal AI Employee Vault inside Bronze-Tier folder
    vault_path = Path(__file__).parent / "Personal AI Employee Vault"
    watch_path = vault_path / "Inbox"  # Watch the Inbox folder for new files

    watcher = FileSystemWatcher(str(vault_path), str(watch_path), check_interval=10)

    print("üöÄ File System Watcher started!")
    print(f"üìÅ Watching: {watch_path}")
    print(f"üíæ Files will be copied to: {watcher.needs_action}")
    print("‚èπ Pause: Ctrl+C to stop")

    watcher.run()